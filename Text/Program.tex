Для проведения расчетов была написан программный комплекс, позволяющий эффективно решать поставленную задачу и ряд сопутствующих проблем. Его разработка велась на языке программирование C++ с использованием компилятора из GNU Compiler Collection и системы автоматизации сборки программного обеспечения из исходного кода CMake. Для решения некоторых задач использовались сторонние инструменты. Так, для пофилирования использовались Valgrind и AMD CodeAnalyst, для визуализации полученных данных - Gnuplot, для генерации документации - Doxygen. Разработка велась под управлением системы контроля версий Git, исходный код был расположен в репозитории code.google.com под академической лицензией MIT.

Написанный программный комплекс	реализует алгоритмы, описанные в предыдущих разделах, и позволяет моделировать движение свободной поверхности жидкости при различных условиях. Моделирование может происходить на основе линейных или нелинейных уравнений, с разными начальными данными, параметрами расчетов и формой дна.

Изменяемыми являются:
\begin{itemize}
    \item начальное значение свободной поверхности
    \item начальное значение распределения скоростей
    \item уравнение, описывающее статическую часть дна
    \item уравнение, описывающее динамическую часть дна
    \item параметры расчетной области
    \item параметры численного метода
    \item значение шага по времени и продолжительность моделирования
\end{itemize}

В процессе работы программного комплекса формируются файлы, содержащие расчетные данные. Они полностью описывают итоговое распределение скоростей и положение свободной поверхности на каждом временном шаге. Помимо этого, можно выполнить сравнение полученных результатов и также получить файл с данными, описывающими отличия.

Все расчетные данные могут быть визуализированы в двух основных представлениях - с учетом дна и в проекции сверху.

\addtocounter{subsection}{1}
\setcounter{equation}{0}
\subsection*{Решенные задачи}
\addtocontents{toc}{\contentsline{subsection}{\protect\numberline{\thesubsection.}\vspace{10pt}Решенные задачи}{\thepage}}

В рамках разработки расчетного программного комплекса были решены некоторые проблемы:

\addtocounter{subsubsection}{1}
\subsubsection*{Гибкость и документирование}
\addtocontents{toc}{\contentsline{subsubsection}{\protect\numberline{\thesubsubsection.}\vspace{10pt}Гибкость и документирование}{\thepage}}

Для гибкого конфигурирования и кросплатформенности для сборки проекта были выбраны компилятор g++ из состава GCC, а также система автоматической сборки Cmake. Данные инструменты могут быть использованы на любой платформе, а также поддерживают достаточно удобное управление компиляцией с помощью разнообразных ключей, которые подробно описаны в документации к соответствующим инструментам.

Чтобы улучшить понимаемость исходного кода был использован генератор документации Doxygen. Соответствующим образом был доработан проект, в него были добавлены описания всех используемых классов и методов, а также формат генерируемой документации. В итоге получено достаточно полное описание кода в виде связанных html страниц, которое поможет разработчику гораздо легче разобраться в проекте.

\addtocounter{subsubsection}{1}
\subsubsection*{Визуализация расчетных данных}
\addtocontents{toc}{\contentsline{subsubsection}{\protect\numberline{\thesubsubsection.}\vspace{10pt}Визуализация расчетных данных}{\thepage}}

В качестве инструмента для визуализации расчетных данных был выбран Gnuplot, т.к. он позволяет задавать параметры и способ визуализации с помощью скриптов. Это позволяет достаточно легко сформировать сложную 3d композицию на основе расчетных данных, в которой каждый элемент легко может быть настроен необходимым образом. Результатом работы Gnuplot является gif файл, который в дальнейшем преобразуется в видео файл с помощью выбранного кодека (mpeg2 для совместимости или mpeg4 для лучшего отображения).

Помимо этого была написана небольшая утилита для конвертирования результатов, отформатированных для Tecplot, в формат Gnuplot.

На листинге (\ref{lst:create_animation}) представлено тело скрипта, использованного для визуализации.


\begin{lstlisting}[language=bash,caption=Пример скрипта для визуализации,label={lst:create_animation}]
#!/bin/bash
MAX=$4
echo "clear" >> $1
echo "reset" >> $1
echo "set terminal gif animate delay 10 giant size 1280,1024" >> $1
echo "set palette defined (0 \"black\", 0.001 \"blue\", 0.004 \"green\",0.006 \"yellow\",0.007 \"red\")" >> $1
#echo "set pal gray" >> $1
echo "set output \""$2"\"" >> $1
echo "unset xtics">>$1
echo "unset ytics">>$1
echo "unset ztics">>$1
echo "unset border">>$1

echo "set xrange [0:1]" >> $1
echo "set yrange [0:1]" >> $1
echo "set zrange [-0.011:0.007]" >> $1
echo "set cbrange[-0.003:0.007]" >> $1
for i in `seq 0 ${MAX}`
do
echo "set multiplot" >> $1
echo "set size 0.7,0.7" >> $1
echo "set origin 0.15,-0.15" >> $1
echo "set view 90,0" >> $1
echo "splot \""h.dat"\" with lines t \"\",\""$3"\" index $i using 1:2:3 with pm3d t \"\"" >> $1

echo "set size 0.7,0.7" >> $1
echo "set origin 0.15,0.35" >> $1
echo "set view 60,30" >> $1
echo "splot \""h.dat"\" with lines t \"\",\""$3"\" index $i using 1:2:3 with pm3d lc rgb \"black\" t \"\"" >> $1

echo "unset multiplot" >> $1
done
\end{lstlisting}

\addtocounter{subsubsection}{1}
\subsubsection*{Оптимизация времени работы}
\addtocontents{toc}{\contentsline{subsubsection}{\protect\numberline{\thesubsubsection.}\vspace{10pt}Оптимизация времени работы}{\thepage}}

В процессе разработки часть усилий была протрачена на оптимизацию программы. Увеличение производительности происходило 2-мя путями:
\begin{itemize}
    \item Выявление ненужных действий и <<узких>> мест в программной реализации алгоритма
    \item Использование возможностей компилятора. Были проанализированы различные настройки компилятора gcc и их влияние на производительность генерируемого кода. Здесь стоит отметить, что современные компиляторы ориентированы на создание более универсальных программ, поэтому добавляют в генерируемый машинный код некоторое количество полезного в общем случае функционала. Но расчетные программы являются узкоспециализированными и не нуждаются в нем, соответственно, отключая данные возможности можно оптимизировать по скорости получаемый код.
\end{itemize}

Оба вида оптимизации не затрагивали алгоритм решения задачи, т.е. неоптимизированный код эквивалентен оптимизированному.

\begin{table}[H]
    \label{tab:CXXFLAGS}
    \caption{Используемые флаги компиляции}
    \begin{center}
    \large{
	\begin{tabular}{|p{0.3\linewidth}|p{0.5\linewidth}|}
	    \hline
	    Ключ & Описание\\
	    \hline
	    o3 & Наивысший уровень оптимизации(компилятор выбирает почти все опции, позволяющие генерировать быстрый код)\\
	    \hline
	    march=native & Указывает компилятору определить тип процессора и оптимизировать код для него\\
	    \hline
	    ffast-math (либо только funsafe-math-optimization) & Устанавливает режим <<быстрой математики>> для программ, в которых не требуется точной реализации IEEE/ISO стандартов для математических функций\\
	    \hline
	    fomit-frame-pointer & Разрешает не хранить в регистрах указатель на фрейм для функции, которая больше не используется (эта опция уже включена в o3, но иногда явное ее указание заметно улучшает производительность)\\
	    \hline
	    fno-stack-protector & Убирает проверку целостности стека после выхода из функции\\
	    \hline
	    fprefetch-loop-array & Генерирует инструкции для предварительной выборки в циклах с большими массивами (если позволяет архитектура целевой машины)\\
	    \hline
	    funsafe-loop-optimizations & Указывает, что циклы в программе не переполняются и не являются бесконечными, что позволяет сгенерировать более быстрый код\\
	    \hline
	    funroll-loops & Позволяет раскрыть циклы, размер которых может быть вычислен на этапе компиляции\\
	    \hline
	    mpreferred-stack-boundary=num & Указывает выравнивание для стека и в некоторых случаях влияет на скорость (по умолчанию num=2, в случае данной программы наибольшая скорость выполнения была получена при num=6)\\
	    \hline
	    ftracer & Форсирует хвостовую дубликацию, делая управление потоком выполнения более простым\\
	    \hline
	\end{tabular}
	}
    \end{center}
\end{table}

К возможностям компилятора также относится и компиляция с обратной связью (Profile-guided optimization). В отличие от традиционных способов оптимизации анализирующих исключительно исходные коды, PGO использует результаты измерений тестовых запусков оптимизируемой программы для генерации более оптимального кода. Тестовые запуски выявляют какие части программы исполняются чаще, а какие реже. Преимущество такого подхода в том что компилятор не строит предположений при выборе способа оптимизации, а использует реальную статистику, собранную во время выполнения программы. В силу специфики расчетных программ данный вид оптимизации оказывается достаточно действенным. Техники оптимизации PGO реализованы, во многих компиляторах, в частности: Intel C++ Compiler, Inter Fortran Compiler, GCC, Sun Studio, Microsoft Visual C++, поэтому они могут быть использованы практически в любом расчетном проекте вне зависимости от платформы.

Пример использования техники PGO для gcc выглядит следующим образом:

\begin{lstlisting}[language=bash,caption=Пример компиляции для сбора статистики,label={lst:profile_generate}]
g++ -O3 -fprofile-generate -c -fmessage-length=0 -MMD -MP -MF program.d -MT program.d -o program.o program.cpp

g++ -fprofile-generate -o program ./program.o
\end{lstlisting}

Для сбора статистики используется ключ {\bf fprofile-generate}, а результатом компиляции являются объектные файлы. Затем тот же ключ необходимо отдельно указать линковщику. Полученная в итоге программа будет работать медленнее, т.к. собирает статистику о действиях программы, которая затем будет помещена в файл с расширением {\bf *.gcda}.

После этого необходимо вновь скомпилировать программу, но уже с учетом набранной статистики - для этого аналогичным образом используется флаг {\bf fprofile-use}.

\begin{lstlisting}[language=bash,caption=Пример компиляции с учетом статистики,label={lst:profile_use}]
g++ -O3 -fprofile-use -c -fmessage-length=0 -MMD -MP -MF program.d -MT program.d -o program.o program.cpp

g++ -fprofile-use -o program ./program.o
\end{lstlisting}

\newpage
\addtocounter{subsection}{1}
\setcounter{equation}{0}
\subsection*{Сервер вычислений}
\addtocontents{toc}{\contentsline{subsection}{\protect\numberline{\thesubsection.}\vspace{10pt}Сервер вычислений}{\thepage}}

Моделирование движения жидкости с помощью разработанной программы требует выполнения последовательности действий и вовлечения в процесс обработки некоторых инструментов. Это, например, сборка программы с изменениями, внесенными в алгоритм, запуск программы с определенными параметрами, визуализация полученных данных. В обычном случае многие из этих действий выполняются исследователем вручную. Для облегчения работы было создано небольшое приложение (<<сервер вычислений>>), которое позволяет объединить необходимые для моделирования действия в рамках одной среды, а также делает работу более удобной.

Требования, которые могут предъявляться к серверу:
\begin{itemize}
	\item Сборка и выполнение расчетной программы
	\item Управление запущенными программами
	\item Пост- и преобработка результатов
	\item Управление файлами и хранение информации, описывающей расчет
	\item Загрузка полученных результатов
\end{itemize}

Основные принципы, используемые в процессе его разработки:
\begin{itemize}
    \item Объединение различных процессов, составляющих проведение расчета
    \item Создание <<обертки>> вокруг уже существующего кода
    \item Гибкость доступа и работы с процессами расчета (запуск,получение информациио состоянии запущенных задач, отмена задачи и т.д.)
    \item Легкая адаптируемость под разные задачи
\end{itemize}

<<Сервер вычислений>> представляет собой TCP сервер, написанный на скриптовом языке python. В нем заложен общий алгоритм проведения расчета, каждый конкретный этап которого реализуется отдельным модулем. Т.о. реализуется шаблон <<стратегия>>, и достигается высокий уровень гибкости, т.к. python позволяет создавать новые модули в замен старых без необходимости создания структуры интерфейсов и изменения исходного кода.

Сервер принимает сообщения в формате xml, описывающие команды к выполнению. Например, запустить указанную программу с выбранными параметрами, что позволяет достаточно легко адаптировать сервер к новым задачам.

При этом на исходный код расчетной программы не накладывается практически никаких ограничений. Сервер просто запускает ее и анализирует результат ее работы, получаемый из стандартного потока вывода. Т.о. например, реализована возможность отслеживания состояния запущенной программы, тогда как, например, во многих планировщиках задач, испольуемых на вычислительных кластерах (Altair PBS), эта информация недоступна.

На данный момент реализован основной функционал сервера вычислений, позволяющий использовать его в работе. Написаны модули, позволяющие производить предварительную обработку кода программы - компиляцию с помощью GCC и утилиты Make, и визуализировать результаты с использованием Gnuplot.